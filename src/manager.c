/* manager.c generated by valac 0.11.6.38-0ec3, the Vala compiler
 * generated from manager.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gstdio.h>


#define SMART_TYPE_NOTEBOOK_MANAGER (smart_notebook_manager_get_type ())
#define SMART_NOTEBOOK_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SMART_TYPE_NOTEBOOK_MANAGER, SmartNotebookManager))
#define SMART_NOTEBOOK_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SMART_TYPE_NOTEBOOK_MANAGER, SmartNotebookManagerClass))
#define SMART_IS_NOTEBOOK_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SMART_TYPE_NOTEBOOK_MANAGER))
#define SMART_IS_NOTEBOOK_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SMART_TYPE_NOTEBOOK_MANAGER))
#define SMART_NOTEBOOK_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SMART_TYPE_NOTEBOOK_MANAGER, SmartNotebookManagerClass))

typedef struct _SmartNotebookManager SmartNotebookManager;
typedef struct _SmartNotebookManagerClass SmartNotebookManagerClass;
typedef struct _SmartNotebookManagerPrivate SmartNotebookManagerPrivate;

#define SMART_TYPE_NOTEBOOK_TAB (smart_notebook_tab_get_type ())
#define SMART_NOTEBOOK_TAB(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SMART_TYPE_NOTEBOOK_TAB, SmartNotebookTab))
#define SMART_NOTEBOOK_TAB_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SMART_TYPE_NOTEBOOK_TAB, SmartNotebookTabClass))
#define SMART_IS_NOTEBOOK_TAB(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SMART_TYPE_NOTEBOOK_TAB))
#define SMART_IS_NOTEBOOK_TAB_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SMART_TYPE_NOTEBOOK_TAB))
#define SMART_NOTEBOOK_TAB_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SMART_TYPE_NOTEBOOK_TAB, SmartNotebookTabClass))

typedef struct _SmartNotebookTab SmartNotebookTab;
typedef struct _SmartNotebookTabClass SmartNotebookTabClass;

#define SMART_TYPE_NOTEBOOK (smart_notebook_get_type ())
#define SMART_NOTEBOOK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SMART_TYPE_NOTEBOOK, SmartNotebook))
#define SMART_NOTEBOOK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SMART_TYPE_NOTEBOOK, SmartNotebookClass))
#define SMART_IS_NOTEBOOK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SMART_TYPE_NOTEBOOK))
#define SMART_IS_NOTEBOOK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SMART_TYPE_NOTEBOOK))
#define SMART_NOTEBOOK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SMART_TYPE_NOTEBOOK, SmartNotebookClass))

typedef struct _SmartNotebook SmartNotebook;
typedef struct _SmartNotebookClass SmartNotebookClass;
#define _g_ptr_array_unref0(var) ((var == NULL) ? NULL : (var = (g_ptr_array_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_key_file_free0(var) ((var == NULL) ? NULL : (var = (g_key_file_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _SmartNotebookManager {
	GObject parent_instance;
	SmartNotebookManagerPrivate * priv;
};

struct _SmartNotebookManagerClass {
	GObjectClass parent_class;
};

struct _SmartNotebookManagerPrivate {
	SmartNotebookTab** _all_tabs;
	gint _all_tabs_length1;
	gint __all_tabs_size_;
	GPtrArray* _notebooks;
	gchar* _name;
};


static gpointer smart_notebook_manager_parent_class = NULL;

GType smart_notebook_manager_get_type (void) G_GNUC_CONST;
GType smart_notebook_tab_get_type (void) G_GNUC_CONST;
GType smart_notebook_get_type (void) G_GNUC_CONST;
#define SMART_NOTEBOOK_MANAGER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SMART_TYPE_NOTEBOOK_MANAGER, SmartNotebookManagerPrivate))
enum  {
	SMART_NOTEBOOK_MANAGER_DUMMY_PROPERTY,
	SMART_NOTEBOOK_MANAGER_NOTEBOOKS,
	SMART_NOTEBOOK_MANAGER_DATA_FILE,
	SMART_NOTEBOOK_MANAGER_NAME
};
SmartNotebookManager* smart_notebook_manager_new (const gchar* name);
SmartNotebookManager* smart_notebook_manager_construct (GType object_type, const gchar* name);
void smart_notebook_manager_set_name (SmartNotebookManager* self, const gchar* value);
static void _g_object_unref0_ (gpointer var);
void smart_notebook_manager_register_notebook (SmartNotebookManager* self, SmartNotebook* smart_notebook);
GPtrArray* smart_notebook_manager_get_notebooks (SmartNotebookManager* self);
const gchar* smart_notebook_manager_get_name (SmartNotebookManager* self);
void smart_notebook_manager_unregister_notebook (SmartNotebookManager* self, SmartNotebook* smart_notebook);
void smart_notebook_manager_store_notebook_tab_positions (SmartNotebookManager* self, const gchar* positions_file);
GPtrArray* smart_notebook_get_tabs (SmartNotebook* self);
const gchar* smart_notebook_tab_get_name (SmartNotebookTab* self);
void smart_notebook_manager_load_notebook_tab_positions (SmartNotebookManager* self, const gchar* positions_file);
const gchar* smart_notebook_manager_get_data_file (SmartNotebookManager* self);
static void _g_free0_ (gpointer var);
SmartNotebookTab** smart_notebook_manager_get_all_tabs (SmartNotebookManager* self, int* result_length1);
void smart_notebook_manager_set_all_tabs (SmartNotebookManager* self, SmartNotebookTab** value, int value_length1);
static SmartNotebookTab** _vala_array_dup1 (SmartNotebookTab** self, int length);
static void smart_notebook_manager_finalize (GObject* obj);
static void _vala_smart_notebook_manager_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_smart_notebook_manager_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


SmartNotebookManager* smart_notebook_manager_construct (GType object_type, const gchar* name) {
	SmartNotebookManager * self = NULL;
	GPtrArray* _tmp0_ = NULL;
	g_return_val_if_fail (name != NULL, NULL);
	self = (SmartNotebookManager*) g_object_new (object_type, NULL);
	smart_notebook_manager_set_name (self, name);
	_tmp0_ = g_ptr_array_new_with_free_func (_g_object_unref0_);
	_g_ptr_array_unref0 (self->priv->_notebooks);
	self->priv->_notebooks = _tmp0_;
	g_debug ("manager.vala:23: Initialized SmartNotebookManager: %s", name);
	return self;
}


SmartNotebookManager* smart_notebook_manager_new (const gchar* name) {
	return smart_notebook_manager_construct (SMART_TYPE_NOTEBOOK_MANAGER, name);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void smart_notebook_manager_register_notebook (SmartNotebookManager* self, SmartNotebook* smart_notebook) {
	GPtrArray* _tmp0_ = NULL;
	SmartNotebook* _tmp1_;
	guint _tmp2_;
	const gchar* _tmp3_ = NULL;
	void* _tmp4_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (smart_notebook != NULL);
	_tmp0_ = smart_notebook_manager_get_notebooks (self);
	_tmp1_ = _g_object_ref0 (smart_notebook);
	g_ptr_array_add (_tmp0_, _tmp1_);
	_tmp2_ = g_str_hash (self->priv->_name);
	gtk_notebook_set_group ((GtkNotebook*) smart_notebook, (void*) _tmp2_);
	_tmp3_ = gtk_widget_get_name ((GtkWidget*) smart_notebook);
	_tmp4_ = gtk_notebook_get_group ((GtkNotebook*) smart_notebook);
	g_debug ("manager.vala:30: Added SmartNotebook: %s to group %u", _tmp3_, (guint) _tmp4_);
}


void smart_notebook_manager_unregister_notebook (SmartNotebookManager* self, SmartNotebook* smart_notebook) {
	GPtrArray* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (smart_notebook != NULL);
	_tmp0_ = smart_notebook_manager_get_notebooks (self);
	g_ptr_array_remove (_tmp0_, smart_notebook);
	_tmp1_ = gtk_widget_get_name ((GtkWidget*) smart_notebook);
	g_debug ("manager.vala:37: Removed SmartNotebook: %s", _tmp1_);
}


static gint g_ptr_array_get_length (GPtrArray* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = (gint) self->len;
	return result;
}


static void g_ptr_array_set_length (GPtrArray* self, gint value) {
	g_return_if_fail (self != NULL);
	g_ptr_array_set_size (self, value);
}


void smart_notebook_manager_store_notebook_tab_positions (SmartNotebookManager* self, const gchar* positions_file) {
	GKeyFile* _tmp0_ = NULL;
	GKeyFile* kf;
	gboolean _tmp1_;
	gboolean _tmp2_;
	gchar* _tmp23_ = NULL;
	gchar* _tmp24_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (positions_file != NULL);
	_tmp0_ = g_key_file_new ();
	kf = _tmp0_;
	_tmp1_ = g_key_file_load_from_file (kf, positions_file, G_KEY_FILE_KEEP_COMMENTS | G_KEY_FILE_KEEP_TRANSLATIONS, &_inner_error_);
	_tmp2_ = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_KEY_FILE_ERROR) {
			goto __catch0_g_key_file_error;
		}
		if (_inner_error_->domain == G_FILE_ERROR) {
			goto __catch0_g_file_error;
		}
		_g_key_file_free0 (kf);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	if (!_tmp2_) {
		g_warning ("manager.vala:48: Couldn't load data file.");
		_g_key_file_free0 (kf);
		return;
	}
	{
		gint n;
		n = 0;
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				GPtrArray* _tmp4_ = NULL;
				gint _tmp5_;
				gchar* _tmp6_;
				gchar* tabs;
				GPtrArray* _tmp20_ = NULL;
				gconstpointer _tmp21_ = NULL;
				const gchar* _tmp22_ = NULL;
				if (!_tmp3_) {
					n++;
				}
				_tmp3_ = FALSE;
				_tmp4_ = smart_notebook_manager_get_notebooks (self);
				_tmp5_ = g_ptr_array_get_length (_tmp4_);
				if (!(n < _tmp5_)) {
					break;
				}
				_tmp6_ = g_strdup ("");
				tabs = _tmp6_;
				{
					gint t;
					t = 0;
					{
						gboolean _tmp7_;
						_tmp7_ = TRUE;
						while (TRUE) {
							GPtrArray* _tmp8_ = NULL;
							gconstpointer _tmp9_ = NULL;
							GPtrArray* _tmp10_ = NULL;
							gint _tmp11_;
							GPtrArray* _tmp12_ = NULL;
							gconstpointer _tmp13_ = NULL;
							GPtrArray* _tmp14_ = NULL;
							gconstpointer _tmp15_ = NULL;
							const gchar* _tmp16_ = NULL;
							gchar* _tmp17_ = NULL;
							gchar* _tmp18_;
							gchar* _tmp19_;
							if (!_tmp7_) {
								t++;
							}
							_tmp7_ = FALSE;
							_tmp8_ = smart_notebook_manager_get_notebooks (self);
							_tmp9_ = g_ptr_array_index (_tmp8_, (guint) n);
							_tmp10_ = smart_notebook_get_tabs ((SmartNotebook*) _tmp9_);
							_tmp11_ = g_ptr_array_get_length (_tmp10_);
							if (!(t < _tmp11_)) {
								break;
							}
							_tmp12_ = smart_notebook_manager_get_notebooks (self);
							_tmp13_ = g_ptr_array_index (_tmp12_, (guint) n);
							_tmp14_ = smart_notebook_get_tabs ((SmartNotebook*) _tmp13_);
							_tmp15_ = g_ptr_array_index (_tmp14_, (guint) t);
							_tmp16_ = smart_notebook_tab_get_name ((SmartNotebookTab*) _tmp15_);
							_tmp17_ = g_strdup_printf ("%s;", _tmp16_);
							_tmp18_ = _tmp17_;
							_tmp19_ = g_strconcat (tabs, _tmp18_, NULL);
							_g_free0 (tabs);
							tabs = _tmp19_;
							_g_free0 (_tmp18_);
						}
					}
				}
				_tmp20_ = smart_notebook_manager_get_notebooks (self);
				_tmp21_ = g_ptr_array_index (_tmp20_, (guint) n);
				_tmp22_ = gtk_widget_get_name ((GtkWidget*) ((SmartNotebook*) _tmp21_));
				g_key_file_set_string (kf, self->priv->_name, _tmp22_, tabs);
				_g_free0 (tabs);
			}
		}
	}
	_tmp23_ = g_key_file_to_data (kf, NULL, NULL);
	_tmp24_ = _tmp23_;
	g_file_set_contents (positions_file, _tmp24_, (gssize) (-1), &_inner_error_);
	_g_free0 (_tmp24_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_KEY_FILE_ERROR) {
			goto __catch0_g_key_file_error;
		}
		if (_inner_error_->domain == G_FILE_ERROR) {
			goto __catch0_g_file_error;
		}
		_g_key_file_free0 (kf);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	goto __finally0;
	__catch0_g_key_file_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_warning ("manager.vala:62: KeyFileError: %s", e->message);
		_g_error_free0 (e);
	}
	goto __finally0;
	__catch0_g_file_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_warning ("manager.vala:63: FileError: %s", e->message);
		_g_error_free0 (e);
	}
	__finally0:
	if (_inner_error_ != NULL) {
		_g_key_file_free0 (kf);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_key_file_free0 (kf);
}


static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


void smart_notebook_manager_load_notebook_tab_positions (SmartNotebookManager* self, const gchar* positions_file) {
	GKeyFile* _tmp0_ = NULL;
	GKeyFile* kf;
	const gchar* _tmp1_ = NULL;
	gboolean _tmp2_;
	gboolean _tmp3_;
	GPtrArray* _tmp4_ = NULL;
	GPtrArray* nb_tabs;
	gsize _tmp5_;
	gchar** _tmp6_ = NULL;
	gchar** _tmp7_;
	gint _tmp7__length1;
	gint __tmp7__size_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (positions_file != NULL);
	_tmp0_ = g_key_file_new ();
	kf = _tmp0_;
	_tmp1_ = smart_notebook_manager_get_data_file (self);
	_tmp2_ = g_key_file_load_from_file (kf, _tmp1_, G_KEY_FILE_KEEP_COMMENTS | G_KEY_FILE_KEEP_TRANSLATIONS, &_inner_error_);
	_tmp3_ = _tmp2_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_KEY_FILE_ERROR) {
			goto __catch1_g_key_file_error;
		}
		if (_inner_error_->domain == G_FILE_ERROR) {
			goto __catch1_g_file_error;
		}
		_g_key_file_free0 (kf);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	if (!_tmp3_) {
		g_warning ("manager.vala:74: Couldn't load data file.");
		_g_key_file_free0 (kf);
		return;
	}
	_tmp4_ = g_ptr_array_new_with_free_func (_g_free0_);
	nb_tabs = _tmp4_;
	_tmp6_ = g_key_file_get_keys (kf, self->priv->_name, &_tmp5_, &_inner_error_);
	_tmp7_ = _tmp6_;
	_tmp7__length1 = _tmp5_;
	__tmp7__size_ = _tmp5_;
	if (_inner_error_ != NULL) {
		_g_ptr_array_unref0 (nb_tabs);
		if (_inner_error_->domain == G_KEY_FILE_ERROR) {
			goto __catch1_g_key_file_error;
		}
		if (_inner_error_->domain == G_FILE_ERROR) {
			goto __catch1_g_file_error;
		}
		_g_ptr_array_unref0 (nb_tabs);
		_g_key_file_free0 (kf);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	{
		gchar** key_name_collection;
		int key_name_collection_length1;
		int key_name_it;
		key_name_collection = _tmp7_;
		key_name_collection_length1 = _tmp7__length1;
		for (key_name_it = 0; key_name_it < _tmp7__length1; key_name_it = key_name_it + 1) {
			gchar* _tmp8_;
			gchar* key_name;
			_tmp8_ = g_strdup (key_name_collection[key_name_it]);
			key_name = _tmp8_;
			{
				{
					gint n;
					n = 0;
					{
						gboolean _tmp9_;
						_tmp9_ = TRUE;
						while (TRUE) {
							GPtrArray* _tmp10_ = NULL;
							gint _tmp11_;
							GPtrArray* _tmp12_ = NULL;
							gconstpointer _tmp13_ = NULL;
							const gchar* _tmp14_ = NULL;
							if (!_tmp9_) {
								n++;
							}
							_tmp9_ = FALSE;
							_tmp10_ = smart_notebook_manager_get_notebooks (self);
							_tmp11_ = g_ptr_array_get_length (_tmp10_);
							if (!(n < _tmp11_)) {
								break;
							}
							_tmp12_ = smart_notebook_manager_get_notebooks (self);
							_tmp13_ = g_ptr_array_index (_tmp12_, (guint) n);
							_tmp14_ = gtk_widget_get_name ((GtkWidget*) ((SmartNotebook*) _tmp13_));
							if (g_strcmp0 (key_name, _tmp14_) == 0) {
								gchar* _tmp15_ = NULL;
								gchar* s;
								gchar* _tmp16_;
								_tmp15_ = g_key_file_get_string (kf, self->priv->_name, key_name, &_inner_error_);
								s = _tmp15_;
								if (_inner_error_ != NULL) {
									_g_free0 (key_name);
									key_name_collection = (_vala_array_free (key_name_collection, key_name_collection_length1, (GDestroyNotify) g_free), NULL);
									_g_ptr_array_unref0 (nb_tabs);
									if (_inner_error_->domain == G_KEY_FILE_ERROR) {
										goto __catch1_g_key_file_error;
									}
									if (_inner_error_->domain == G_FILE_ERROR) {
										goto __catch1_g_file_error;
									}
									_g_free0 (key_name);
									key_name_collection = (_vala_array_free (key_name_collection, key_name_collection_length1, (GDestroyNotify) g_free), NULL);
									_g_ptr_array_unref0 (nb_tabs);
									_g_key_file_free0 (kf);
									g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return;
								}
								_tmp16_ = g_strdup (s);
								g_ptr_array_add (nb_tabs, _tmp16_);
								g_debug ("manager.vala:88: %s: %s", key_name, s);
								_g_free0 (s);
							}
						}
					}
				}
				_g_free0 (key_name);
			}
		}
		key_name_collection = (_vala_array_free (key_name_collection, key_name_collection_length1, (GDestroyNotify) g_free), NULL);
	}
	_g_ptr_array_unref0 (nb_tabs);
	goto __finally1;
	__catch1_g_key_file_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_warning ("manager.vala:95: KeyFileError: %s", e->message);
		_g_error_free0 (e);
	}
	goto __finally1;
	__catch1_g_file_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_warning ("manager.vala:96: FileError: %s", e->message);
		_g_error_free0 (e);
	}
	__finally1:
	if (_inner_error_ != NULL) {
		_g_key_file_free0 (kf);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_key_file_free0 (kf);
}


GPtrArray* smart_notebook_manager_get_notebooks (SmartNotebookManager* self) {
	GPtrArray* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_notebooks;
	return result;
}


SmartNotebookTab** smart_notebook_manager_get_all_tabs (SmartNotebookManager* self, int* result_length1) {
	SmartNotebookTab** result;
	SmartNotebookTab** _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_all_tabs;
	*result_length1 = self->priv->_all_tabs_length1;
	result = _tmp0_;
	return result;
}


static SmartNotebookTab** _vala_array_dup1 (SmartNotebookTab** self, int length) {
	SmartNotebookTab** result;
	int i;
	result = g_new0 (SmartNotebookTab*, length + 1);
	for (i = 0; i < length; i++) {
		result[i] = _g_object_ref0 (self[i]);
	}
	return result;
}


void smart_notebook_manager_set_all_tabs (SmartNotebookManager* self, SmartNotebookTab** value, int value_length1) {
	SmartNotebookTab** _tmp0_;
	SmartNotebookTab** _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = (_tmp1_ = value, (_tmp1_ == NULL) ? ((gpointer) _tmp1_) : _vala_array_dup1 (_tmp1_, value_length1));
	self->priv->_all_tabs = (_vala_array_free (self->priv->_all_tabs, self->priv->_all_tabs_length1, (GDestroyNotify) g_object_unref), NULL);
	self->priv->_all_tabs = _tmp0_;
	self->priv->_all_tabs_length1 = value_length1;
	self->priv->__all_tabs_size_ = value_length1;
}


const gchar* smart_notebook_manager_get_data_file (SmartNotebookManager* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = "notebook_manager.conf";
	return result;
}


const gchar* smart_notebook_manager_get_name (SmartNotebookManager* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_name;
	return result;
}


void smart_notebook_manager_set_name (SmartNotebookManager* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_name);
	self->priv->_name = _tmp0_;
	g_object_notify ((GObject *) self, "name");
}


static void smart_notebook_manager_class_init (SmartNotebookManagerClass * klass) {
	smart_notebook_manager_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SmartNotebookManagerPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_smart_notebook_manager_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_smart_notebook_manager_set_property;
	G_OBJECT_CLASS (klass)->finalize = smart_notebook_manager_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SMART_NOTEBOOK_MANAGER_NOTEBOOKS, g_param_spec_boxed ("notebooks", "notebooks", "notebooks", G_TYPE_PTR_ARRAY, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SMART_NOTEBOOK_MANAGER_DATA_FILE, g_param_spec_string ("data-file", "data-file", "data-file", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SMART_NOTEBOOK_MANAGER_NAME, g_param_spec_string ("name", "name", "name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void smart_notebook_manager_instance_init (SmartNotebookManager * self) {
	self->priv = SMART_NOTEBOOK_MANAGER_GET_PRIVATE (self);
}


static void smart_notebook_manager_finalize (GObject* obj) {
	SmartNotebookManager * self;
	self = SMART_NOTEBOOK_MANAGER (obj);
	self->priv->_all_tabs = (_vala_array_free (self->priv->_all_tabs, self->priv->_all_tabs_length1, (GDestroyNotify) g_object_unref), NULL);
	_g_ptr_array_unref0 (self->priv->_notebooks);
	_g_free0 (self->priv->_name);
	G_OBJECT_CLASS (smart_notebook_manager_parent_class)->finalize (obj);
}


GType smart_notebook_manager_get_type (void) {
	static volatile gsize smart_notebook_manager_type_id__volatile = 0;
	if (g_once_init_enter (&smart_notebook_manager_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SmartNotebookManagerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) smart_notebook_manager_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SmartNotebookManager), 0, (GInstanceInitFunc) smart_notebook_manager_instance_init, NULL };
		GType smart_notebook_manager_type_id;
		smart_notebook_manager_type_id = g_type_register_static (G_TYPE_OBJECT, "SmartNotebookManager", &g_define_type_info, 0);
		g_once_init_leave (&smart_notebook_manager_type_id__volatile, smart_notebook_manager_type_id);
	}
	return smart_notebook_manager_type_id__volatile;
}


static void _vala_smart_notebook_manager_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	SmartNotebookManager * self;
	self = SMART_NOTEBOOK_MANAGER (object);
	switch (property_id) {
		case SMART_NOTEBOOK_MANAGER_NOTEBOOKS:
		g_value_set_boxed (value, smart_notebook_manager_get_notebooks (self));
		break;
		case SMART_NOTEBOOK_MANAGER_DATA_FILE:
		g_value_set_string (value, smart_notebook_manager_get_data_file (self));
		break;
		case SMART_NOTEBOOK_MANAGER_NAME:
		g_value_set_string (value, smart_notebook_manager_get_name (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_smart_notebook_manager_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	SmartNotebookManager * self;
	self = SMART_NOTEBOOK_MANAGER (object);
	switch (property_id) {
		case SMART_NOTEBOOK_MANAGER_NAME:
		smart_notebook_manager_set_name (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



